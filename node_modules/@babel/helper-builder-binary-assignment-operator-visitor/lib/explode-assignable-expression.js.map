{"version":3,"names":["_t","require","assignmentExpression","cloneNode","isIdentifier","isLiteral","isMemberExpression","isPrivateName","isPureish","isSuper","memberExpression","toComputedKey","getObjRef","node","nodes","scope","ref","hasBinding","name","object","Error","temp","generateUidIdentifierBasedOnNode","push","id","getPropRef","prop","property","key","explode","obj","uid","computed"],"sources":["../src/explode-assignable-expression.ts"],"sourcesContent":["import type { Scope } from \"@babel/traverse\";\nimport {\n  assignmentExpression,\n  cloneNode,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isPrivateName,\n  isPureish,\n  isSuper,\n  memberExpression,\n  toComputedKey,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nfunction getObjRef(\n  node: t.Identifier | t.MemberExpression,\n  nodes: Array<t.AssignmentExpression>,\n  scope: Scope,\n): t.Identifier | t.Super {\n  let ref;\n  if (isIdentifier(node)) {\n    if (scope.hasBinding(node.name)) {\n      // this variable is declared in scope so we can be 100% sure\n      // that evaluating it multiple times won't trigger a getter\n      // or something else\n      return node;\n    } else {\n      // could possibly trigger a getter so we need to only evaluate\n      // it once\n      ref = node;\n    }\n  } else if (isMemberExpression(node)) {\n    ref = node.object;\n\n    if (isSuper(ref) || (isIdentifier(ref) && scope.hasBinding(ref.name))) {\n      // the object reference that we need to save is locally declared\n      // so as per the previous comment we can be 100% sure