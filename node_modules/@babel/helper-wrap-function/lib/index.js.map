{"version":3,"names":["_helperFunctionName","require","_template","_t","blockStatement","callExpression","functionExpression","isAssignmentPattern","isFunctionDeclaration","isRestElement","returnStatement","isCallExpression","buildAnonymousExpressionWrapper","template","expression","buildNamedExpressionWrapper","buildDeclarationWrapper","statements","classOrObjectMethod","path","callId","node","body","container","async","generator","get","unwrapFunctionEnvironment","plainFunction","inPath","noNewArrows","ignoreFunctionLength","functionId","nodeParams","params","isArrowFunctionExpression","_path$arrowFunctionTo","arrowFunctionToExpression","isDeclaration","built","id","type","param","push","scope","generateUidIdentifier","wrapperArgs","NAME","REF","name","FUNCTION","PARAMS","replaceWith","insertAfter","returnFn","callee","argument","nameFunction","parent","length","wrapFunction","isMethod"],"sources":["../src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport template from \"@babel/template\";\nimport {\n  blockStatement,\n  callExpression,\n  functionExpression,\n  isAssignmentPattern,\n  isFunctionDeclaration,\n  isRestElement,\n  returnStatement,\n  isCallExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\ntype ExpressionWrapperBuilder<ExtraBody extends t.Node[]> = (\n  replacements?: Parameters<ReturnType<typeof template.expression>>[0],\n) => t.CallExpression & {\n  callee: t.FunctionExpression & {\n    body: {\n      body: [\n        t.VariableDeclaration & {\n          declarations: [\n            { init: t.FunctionExpression | t.ArrowFunctionExpression },\n          ];\n        },\n        ...ExtraBody,\n      ];\n    };\n  };\n};\n\nconst buildAnonymousExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`) as 